<!DOCTYPE html>
<html lang="zh-Hant-TW">
	<head>
		<title>three.js webgl - loader - ttf</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<script src="./opentype.min.js"></script>
		<script src="./three.min.js"></script>
		<script src="./TTFLoader.js"></script>
		<script src="./scoreoutputer.min.js"></script>
		
		<script>
			// 自評
			var so = new ScoreOutputer("110598020");
			so.installCSS(function(){
				so.addChild("創建場警", 1, true);
				so.addChild("排列文字", 1, true);
				so.addChild("讀取字型檔", 2, false);
				so.addChild("鼠標移至文字時文字會變色", 2, true);
				so.addChild("時鐘效果", 1, true);
				so.addChild("顯示[高等計算機圖形作業]", 1, true);
				so.addChild("點擊 12 地支分別跳轉網頁", 1, false);
				so.renderModal(
					//1. 自評表插入位置 (預設 document.body)
					document.body,
					//2. 自評表背景 (預設紅色)
					'rgba(100,45,58,1)', 
					//3. 自評表文字顏色 (預設白色)
					'white', 
					//4. 自評表文字大小 (預設 14pt)
					'15pt', 
					//5. 自評表 checkbox 文字大小 (預設多少忘了)
					'15px', 
					//6. 自評表標題 (預設 "自我評分表")
					dialogTitle='自我評分表'
				);
				so.renderBtn(
					//自評表按鈕插入位置
					document.body,
					//自評表按鈕文字
					"開啟自評表"
				);
			});

			// three
			var fontttf = 'TaipeiSansTCBeta-Regular.ttf';
			

			let container;
			let camera, cameraTarget, scene, renderer;
			let group, textMesh1, textGeo, materialOrigin, materialSelected, ObjectSelected;
			let titleMesh;
			let firstLetter = true;

			const height = 20,
				size = 50,
				hover = 30,
				curveSegments = 4,
				bevelThickness = 2,
				bevelSize = 1.5;

			let font = null;

			let targetRotation = 0;
			let targetRotationOnPointerDown = 0;
			let targetRotationUp = 0;
			let targetRotationUpOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;
			let pointerY = 0;
			let pointerYOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.set( 0, 400, 700 );

				cameraTarget = new THREE.Vector3( 0, 150, 0 );

				// SCENE

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

				// LIGHTS

				const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
				dirLight.position.set( 0, 0, 1 ).normalize();
				scene.add( dirLight );

				const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
				pointLight.position.set( 0, 100, 90 );
				//pointLight.color.setHSL( Math.random(), 1, 0.5 );
				scene.add( pointLight );

				materialOrigin = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
				materialSelected = new THREE.MeshPhongMaterial( { color: 0xff0000, flatShading: true } );

				group = new THREE.Group();
				group.position.y = 100; // 整體位置

				scene.add( group );

				const loader = new THREE.TTFLoader();
				loader.load( fontttf, function ( json ) {
				console.log(json)
					font = new THREE.Font( json );
					createTitle();
					createText('子', -20, 	150, 	-100, 0, Math.PI * 2,0);
					createText('丑', 40, 	130, 	-100, 0, Math.PI * 2,0);
					createText('寅', 100, 	100, 	-100, 0, Math.PI * 2,0);
					createText('卯', 120, 	25, 	-100, 0, Math.PI * 2,0);
					createText('辰', 100, 	-50, 	-100, 0, Math.PI * 2,0);
					createText('己', 40, 	-80, 	-100, 0, Math.PI * 2,0);
					createText('午', -20, 	-100, 	-100, 0, Math.PI * 2,0);
					createText('未', -80, 	-80, 	-100, 0, Math.PI * 2,0);
					createText('申', -140, 	-50, 	-100, 0, Math.PI * 2,0);
					createText('酉', -160, 	25, 	-100, 0, Math.PI * 2,0);
					createText('戌', -140, 	100, 	-100, 0, Math.PI * 2,0);
					createText('亥', -80, 	130, 	-100, 0, Math.PI * 2,0);
				} );
				
				// plane
				const plane = new THREE.Mesh(
					new THREE.PlaneGeometry( 800, 1000 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: false } )
				);
				plane.position.y = 0;
				plane.rotation.x =  -Math.PI/2;
				scene.add( plane );

				// RENDERER

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// EVENTS

				container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown );

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener('mousedown', onMouseDown, false);
				
				

			}

			function render() {
				raycaster.setFromCamera( mouse, camera );

				// calculate objects intersecting the picking ray
				const intersects = raycaster.intersectObjects( group.children );

				// check selected
				for ( let i = 0; i < intersects.length; i ++ ) {

					intersects[ 0 ].object.material = materialSelected;
					if ( ObjectSelected != null && ObjectSelected != intersects[ 0 ].object ){
						ObjectSelected.material = materialOrigin;
					}
					ObjectSelected = intersects[ 0 ].object;
				}

				// check not selected
				if ( ObjectSelected != null && intersects.length == 0){
					ObjectSelected.material = materialOrigin;
					ObjectSelected = null;
				}

				renderer.render( scene, camera );
			
			}

			function onMouseDown( event ) {
			
				if (ObjectSelected != null){
					id = ObjectSelected.id;
					window.location.href = 'https://ntut-cg-lab.github.io/cg2021f-hw00-Ryan-SPC/';
				}		
			}

			function onMouseMove( event ) {
			
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;			
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createTitle() {

				textGeo = new THREE.TextGeometry( "高等計算機圖學", {

					font: font,

					size: 40,
					height: height,
					curveSegments: curveSegments,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: true

				} );

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();

				const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				titleMesh = new THREE.Mesh( textGeo, 
				new THREE.MeshPhongMaterial( { color: 0x0080FF, flatShading: true } )
				);
				titleMesh.position.x = -200;
				titleMesh.position.y = 0;
				titleMesh.position.z = 50;

				titleMesh.rotation.x = -Math.PI * 0.5;
				titleMesh.rotation.y = Math.PI * 2;

				scene.add( titleMesh );

			}

			function createText( text, x, y, z, rx, ry, rz ) {

				textGeo = new THREE.TextGeometry( text, {

					font: font,

					size: 30,
					height: height,
					curveSegments: curveSegments,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: true

				} );

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();

				const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				textMesh1 = new THREE.Mesh( textGeo, materialOrigin );

				textMesh1.position.x = x;
				textMesh1.position.y = y;
				textMesh1.position.z = z;

				textMesh1.rotation.x = rx;
				textMesh1.rotation.y = ry;				

				group.add( textMesh1 );

			}

			function refreshText() {

				group.remove( textMesh1 );

				if ( ! text1 ) return;

				createText();

			}

			function onPointerDown( event ) {

				if ( event.isPrimary === false ) return;

				pointerXOnPointerDown = event.clientX - windowHalfX;
				pointerYOnPointerDown = event.clientY - windowHalfX;
				targetRotationOnPointerDown = targetRotation;
				targetRotationUpOnPointerDown = targetRotationUp;

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				pointerX = event.clientX - windowHalfX;
				pointerY = event.clientY - windowHalfX;

				targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;
				targetRotationUp = targetRotationUpOnPointerDown + (pointerY - pointerYOnPointerDown) * 0.02;

			}

			function onPointerUp() {

				if ( event.isPrimary === false ) return;

				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				scene.rotation.y += ( targetRotation - scene.rotation.y ) * 0.05;
				scene.rotation.x += ( targetRotationUp - scene.rotation.x ) * 0.05;

				camera.lookAt( cameraTarget );

				renderer.render( scene, camera );
				window.requestAnimationFrame(render);

			}
			

		</script>

	</body>
</html>
